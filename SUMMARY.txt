SUMMARY

Leetcode 152:
Суть алгоритма: У нас есть массив, который состоит из положительных или отрицательных целых чисел. Нам необходимо составить такой подмассив исходного массива, что произведение элементов подмассива будет максимальным.

Идея реализации: Я сразу понял, что будет очень много переменных. Начал с того, что выделил три основных - резултат, maxResult, minResult. Причем мне нужно запоминать как максимальный возможный результат, так и минимальный, ведь следующее число может быть отрицательным, которое умножится на minResult (который возможно будет отрицательным) и перегонит произведением maxResult. Или будет наоборот, что получится новое минимальное. И не стоит забывать, что мне придется искать именно непрерывный подмассив. Поэтому внутри цикла создадим 3 переменные - current = ints[i], maxIntermediateResult = maxResult * current;, minIntermediateResult = maxResult * current;. Сделаю проверку на максимум и минимум, причем если current наибольший, то это значит, что нынешнее число отрицательн и дало такое произведение, что максимальное произведение массива оборвалось! Получившиеся результаты из условий мы сохраняем в maxResult, minResult, а после делаем проверку, не превзошел ли maxResult итоговый результат.

Сложность алгоритма: O(n), так как внутри метода MaxInternalArray есть цикл, который принимает от 1 до n-1 входных данных (у n-1 отбрасывается константа в виде -1). Причем сложность всегда будет O(n), ибо внутри цикла есть лишь проверки для нахождения максимальной и минимальной сумму подмассива массива, которые никак не способствуют на досрочное завершения цикла. Итог: Сложность O(n).

Leetcode 42:
Суть алгоритма: Нам дан массив, числа которого имитируют высоту колонн, плотно прижатые друг к другу. Представим, что пошел дождь, и вода залила пустоты между колоннами. Нам нужно вычислисть объем воды, который набрался между колоннами.

Идея реализации: Мне нужно как-то выделить границы площади, в которой будет скапливаться вода. Я бегу по массиву и запоминаю самую наивысшую слева и справа колонну. Окей, просто делаем maxLeft и maxRight. Тогда мы должны делать проверку: Если моя нынешняя колонна выше leftMax (maxRight), то теперь она и будет новой границей, а если нет, то я буду высчитывать сколько осталось до "земли" места и суммировать его к результату.

Сложность алгоритма: O(n), так как мы имеем while, который будет выполняться до тех пор, пока левый указатель не превысит правый (на самом деле сложность n/2, но константы отбрасываются). У нас левый указатель = 0, а правый = длине массива - 1. И при этом на каждой итерации левый увеличивается на 1, а правый - уменьшается. Значит, что каждый элемент обработается один раз. Итог: Сложность: O(n)

task 1:
Идея реализации: Просто буду брать массивы и объединять их в 1 большой массив, а после сортировать пузырьком, так как я глупенький и ленивый.

Сложность алгоритма: O(n^2), так как у нас есть сортировка пузырьком. Хоть у нас может быть множество массивов, собирающихся в один, это все равно будет O(n), но из-за сортировки пузырьком, где 2 цикла, будет O(n^2). И в конце мы получим O(n) + O(n^2), так как сначала соберутся массивы, а потом будет сортировка общего. Но я знаю, что константы отбрасываются. Итог: Сложность O(n^2).

task 2:
Идея реализации: Буду брать пару чисел, переводить их в строки (a, b) и конкатенировать (a+b, b+a), а потом переводить в int и сравнивать, какая конкатенация больше на выходе.

Сложность алгоритма: O(n^2), так как у нас есть два вложенных цикла, отвечающих за перестановку каждого элемента так, чтобы он образовал наибольшее число. Итог: O(n^2).